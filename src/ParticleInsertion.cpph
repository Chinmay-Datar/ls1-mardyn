/*
 * Usher algorithm - inserting particles on
 * the position where teh energy is euqal
 * to the mean energy of the system
 * 
 * Please note that logging is possible but is currently
 * commented out for performance reasons and since 
 * insertions are meant to happen in every timestep
 */

/* 
 * namespace definition etc because of the coupling tool
 */
namespace moleculardynamics {
namespace coupling {

template<class Molecule, class LinkedCells, unsigned int dim>
ParticleInsertion<Molecule, LinkedCells, dim>::ParticleInsertion() {
}
/* 
 * one output vector writing
 */
template<class Molecule, class LinkedCells, unsigned int dim>
void moleculardynamics::coupling::ParticleInsertion<Molecule, LinkedCells, dim>::write_vector(
		vector<double> vec, string file_name) const {
	/*
	 FILE* file = fopen(file_name.c_str(), "w");
	 for (unsigned int i = 0; i < vec.size(); i++) {
	 fprintf(file, "%g \n", vec[i]);
	 }
	 fclose(file);
	 */
}

template<class Molecule, class LinkedCells, unsigned int dim>
void moleculardynamics::coupling::ParticleInsertion<Molecule, LinkedCells, dim>::write_vector_3d(
		std::vector<double*> vec, std::string file_name) const {
	/*
	 FILE* file = fopen(file_name.c_str(), "w");
	 for (unsigned int i = 0; i < vec.size(); i++) {
	 fprintf(file, "%g %g %g \n", vec[i][0], vec[i][1], vec[i][2]);
	 }
	 fclose(file);
	 */
}

/*
 * Writing output for one insertion
 */
template<class Molecule, class LinkedCells, unsigned int dim>
void moleculardynamics::coupling::ParticleInsertion<Molecule, LinkedCells, dim>::doLogging(
		vector<double>* vec_energy, vector<double>* vec_angle,
		vector<double*>* vec_lj, vector<double*>* vec_center,
		string name_energy, string name_angle, string name_lj,
		string name_center) const {
	/*
	 write_vector(*vec_energy, name_energy);
	 write_vector(*vec_angle, name_angle);
	 write_vector_3d(*vec_lj, name_lj);
	 write_vector_3d(*vec_center, name_center);
	 */
}
/*
 * adding values to output vectors
 */
template<class Molecule, class LinkedCells, unsigned int dim>
void moleculardynamics::coupling::ParticleInsertion<Molecule, LinkedCells, dim>::writeToVectors(
		vector<double>* vec_energy, vector<double>* vec_angle,
		vector<double*>* vec_lj, vector<double*>* vec_center, double energy,
		double angle, Molecule* molecule) const {
	/*
	 double* d1 = new double[3];
	 d1[0] = molecule->ljcenter_d(0)[0];
	 d1[1] = molecule->ljcenter_d(0)[1];
	 d1[2] = molecule->ljcenter_d(0)[2];
	 double* d2 = new double[3];
	 d2[0] = molecule->ljcenter_d(1)[0];
	 d2[1] = molecule->ljcenter_d(1)[1];
	 d2[2] = molecule->ljcenter_d(1)[2];
	 double* c = new double[3];
	 c[0] = molecule->r(0);
	 c[1] = molecule->r(1);
	 c[2] = molecule->r(2);

	 vec_lj->push_back(d1);
	 vec_lj->push_back(d2);
	 vec_center->push_back(c);
	 vec_energy->push_back(energy);
	 vec_angle->push_back(angle);
	 */
}
/*
 * MOlecule rotations
 * @param molecule - molecule that is being inserted and rotated
 * @param wrapper - molecule wrapper to be used with LB later
 * @param linkedCells container
 * @param rotationsMax - allowed number of rotations
 * @param maxAngle - if larger than this, angle will be reduced to this
 * @param maxAllowedAngle - if larger than this, rotations will stop
 * @param minAngle - if smaller than this, rotations will stop
 * @param U_0 - target energy
 * @param U_overlap - overlapping energy
 * @param timestep - counting timesteps
 * @param xiMax - tolerance
 * @param energy - current energy
 * @param energyOld - energy from previous timestep
 * @param force - force currently on the molecule
 * @param absFOrce - absolute value of the force
 * @param q - quaternion describing current orientation
 * @param stopIfOverlapping - stop rotations if overlap detected
 * @param log - do logging
 * @param vector<...> vectors for logging 
 * @param string... names of log files
 * @return 1 if target energy reached, 0 otherwise
 */
template<class Molecule, class LinkedCells, unsigned int dim>
int moleculardynamics::coupling::ParticleInsertion<Molecule, LinkedCells, dim>::rotateMolecule(
		Molecule* molecule,
		moleculardynamics::coupling::interface::MardynMoleculeWrapper<Molecule,
				dim> wrapper, LinkedCells* linkedCells, int rotationsMax,
		double maxAngle, double maxAllowedAngle, double minAngle, double U_0,
		double U_overlap, int* timestep, double xiMax, double* energy,
		double* energyOld, double* force, double* absForce, Quaternion* q,
		bool stopIfOverlapping, bool log, vector<double>* vec_energy,
		vector<double>* vec_angle, vector<double*>* vec_lj,
		vector<double*>* vec_center, string name_energy, string name_angle,
		string name_lj, string name_center) const {

	// declarations
	double torque[3];
	double absTorque;
	double angle;

	// rotatefor maximal number of rotations
	for (int iRot = 0; iRot < rotationsMax && molecule->numSites() > 1; iRot++) {

		// get force, energy, absolute value of the force
		molecule->clearFM();
		*energy = linkedCells->getForceAndEnergy(molecule, force);
		molecule->calcFM();
		*absForce = std::sqrt(force[0] * force[0] + 
							  force[1] * force[1] + 
							  force[2] * force[2]);

		if (stopIfOverlapping && (*energy > U_overlap)) {
			//cout << "overlapping, stop rotation" << endl;
			return 0;
		}

		// get torque
		absTorque = 0;
		for (int i = 0; i < 3; i++)
			absTorque += molecule->M(i) * molecule->M(i);

		absTorque = std::sqrt(absTorque);

		for (int i = 0; i < 3; i++)
			torque[i] = (1 / absTorque) * molecule->M(i);

		// compute angle: from de fabritiis paper
		angle = fabs(*energy - U_0) / absTorque;

		writeToVectors(vec_energy, vec_angle, vec_lj, vec_center, *energy,
				angle, molecule);

		// increment timestep
		(*timestep)++;
		//writeMoleculeVtk(molecule, linkedCells, simulation, timestep);

		// absolute distance from target energy
		double xiloc = fabs(*energy - U_0) / fabs(U_0);

		if (fabs(xiloc) < xiMax) {
			//cout << "final energy " << *energy << endl;
			return 1;
		}
		
		// if angle larger than some value (definitely should be smaller than 
		// 360 degrees, no need to rotate, too far away
		if (angle > maxAllowedAngle) {
			//cout << "angle too large, too far away" << endl;
			return 0;
		}
		
		// control angle size - de fabritiis paper
		if (angle > maxAngle) {
			angle = maxAngle;
		}

		// if small rotations needed, stop
		if (angle < minAngle) {
			//cout << "angle too small, not rotating any more" << endl;
			return 0;
		}

		//perform rotation
		q->multiply_left(
				Quaternion(cos(angle / 2), torque[0] * sin(angle / 2),
						torque[1] * sin(angle / 2), torque[2] * sin(angle / 2)));

		molecule->setq(*q);
		molecule->upd_cache();

		*energyOld = *energy;

	}

	// performed maximal number of rotations
	return 0;
}

/*
 * Finds position to insert the particle
 * At exit, particle has the found position
 * @param linkedCells - molecule container
 * @param molecule - molecule to insert
 * @param U_0 - target energy
 * @param energy - where the energy value will be
 * @param energy old - previous timestep energy will be here
 * @param largeStepsizeOnOverlap - if true, do large stepsize on overlap
 * @param restartIfIncreases - restart from rand position if energy increases
 * @param seed - for parameter studies, seed for random number generator (now commented out)
 * @param intIterMax - maximal number of iterations
 * @param restartMax - maximal number of random restarts
 * @param rotationsMax - maximal number of rotations
 * @param maxAngle - if larger, angle will be rounded to this
 * @param maxAllowedAngle - if larger, rotations will stop
 * @param minAngle - if smaller, rotations will stop
 * @param xiMax - tolerance for energy
 * @param vector<...> - output values, currently commented out
 * @param string... - names of output files, currently not used
 * @param allowedLow - lowest allowed position
 * @param allowedHigh - highest allowed position
 * @return number of performed steps if succeded, -1 if failed
 */
template<class Molecule, class LinkedCells, unsigned int dim>
int moleculardynamics::coupling::ParticleInsertion<Molecule, LinkedCells, dim>::findParticlePosition(
		
		LinkedCells* linkedCells, Molecule* molecule, double U_0,
		double* energy, double* energyOld, bool largeStepsizeOnOverlap,
		bool restartIfIncreases, int seed, int intIterMax, int restartMax,
		int rotationsMax, double maxAngle, double maxAllowedAngle,
		double minAngle, double xiMax, vector<double>* vec_energy,
		vector<double>* vec_angle, vector<double*>* vec_lj,
		vector<double*>* vec_center, string name_energy, string name_angle,
		string name_lj, string name_center, double* allowed_low,
		double* allowed_high) const {

	// molecule position
	double* position = new double[3];

	// absolute value of force
	double absForce = 0.0;
	// step size
	double stepSize;

	// fluid parameters
	const double epsilon_times_4 = 4.0 * molecule->getEps();
	const double sigma = molecule->getSigma();

	// clear force and molecule
	molecule->clearFM();

	double* force = new double[3];

	// energy implying a certain overlap with another particle 
	const double U_overlap = 10000 * molecule->getEps();

	// maximum step size allowed
	const double stepRef = 1.12 * sigma; 

	// count timestep
	int timestep = 0;

	// wrapper for the molecule - for LB coupling later
	moleculardynamics::coupling::interface::MardynMoleculeWrapper < Molecule, dim
			> wrapper(molecule);

	// initialize random numbers - put back in for parameter studies
	//srand(seed);
	
	// quaternion defininig molecule orientation
	Quaternion q;
	
	// try at max. restartMax times to insert this particle...
	for (int i = 0; i < restartMax; i++) {

		/*
		 * Molecule can start one linked cell away from the allowed region
		 * This is so that search is not constantly stopped in case of very
		 * narrow allowed regions
		 */
		
		// maximal distance from the low point
		int diff[3];
		for (int d = 0; d < 3; d++)
			diff[d] = allowed_high[d] - allowed_low[d]
					+ linkedCells->getCutoff();

		// random position
		for (unsigned int d = 0; d < dim; d++) {
			position[d] = allowed_low[d] - linkedCells->getCutoff() + diff[d]
					* (rand() / (float) RAND_MAX);
		}
		
		// write out random position on first timestep
		if (i == 0)
			std::cout << "position" << position[0] << " " << position[1] << " "
					<< position[2] << std::endl;
		
		// random orientation at the beginning
		q = Quaternion(rand() / (float) RAND_MAX, rand() / (float) RAND_MAX,
				rand() / (float) RAND_MAX, rand() / (float) RAND_MAX);
		q.normalize();
		

		// set position and orientation
		wrapper.setPosition(position);
		molecule->setq(q);
		molecule->upd_cache();

		// initialize and get force
		for (int d = 0; d < 3; d++)
			force[d] = 0;
		molecule->clearFM();
		*energy = linkedCells->getForceAndEnergy(molecule, force);
		wrapper.setForce(force);
		absForce = std::sqrt(force[0] * force[0] + 
				             force[1] * force[1] + 
				             force[2] * force[2]);

		writeToVectors(vec_energy, vec_angle, vec_lj, vec_center, *energy, 0,
				molecule);
		
		// increment timestep
		timestep++;
		//writeMoleculeVtk(molecule, linkedCells, simulation, &timestep);

		// if exactly zero difference in the first step (to avoid zero values)
		if (*energy - U_0 == 0.0) {
			cout << "exactly zero difference. done. " << endl;
			cout << "total_steps: " << timestep << endl;
			cout << "restarts: " << i << endl;
			doLogging(vec_energy, vec_angle, vec_lj, vec_center, name_energy,
					name_angle, name_lj, name_center);
			return timestep;
		}

		// determine signum - in case we are below the 
		// target energy (very unlikely in real cases)
		const int signAl = static_cast<int> ((*energy - U_0) / fabs(
				*energy - U_0));

		if ((signAl != 1) && (signAl != -1)) {
			std::cout
					<< "ERROR moleculardynamics::coupling::ParticleInsertion::findParticlePosition(): wrong sign in USHER"
					<< signAl << std::endl;
			doLogging(vec_energy, vec_angle, vec_lj, vec_center, name_energy,
					name_angle, name_lj, name_center);
			exit( EXIT_FAILURE);
		}

		// initialize the distance from target energy
		double xiloc = xiMax + 1.0;

		// start doing steps towards the target energy
		for (int loci = 0; loci < intIterMax; loci++) {
			
			// if there is no force on the particle, 
			// either out of cuttof (also energy == 0), or in the
			// center of mass of the system
			// doesn't happen in real cases
			if (absForce == 0) {
				break;
			}

			// control step size
			if (*energy > U_overlap) {
				// if large stepsize on overlap, set it 
				// according to the original usher paper for argon
				if (largeStepsizeOnOverlap) {
					stepSize = 1.12 * sigma - sigma * pow(
							epsilon_times_4 / *energy, (1.0 / 12.0));
				} else {
					stepSize = fabs(*energy - U_0) / absForce;
				}
			} else {
				// no overlap, normal stepsize
				stepSize = fabs(*energy - U_0) / absForce;
				
				// bound to stepRef
				if (stepSize > stepRef) {
					stepSize = stepRef;
				}

			}

			// check if correct stepsize
			if (stepSize <= 0.0) {
				doLogging(vec_energy, vec_angle, vec_lj, vec_center,
						name_energy, name_angle, name_lj, name_center);
				exit( EXIT_FAILURE);
			}

			// update particle position
			for (int d = 0; d < 3; d++)
				position[d] = position[d] + (stepSize * signAl / absForce)
						* force[d];
			wrapper.setPosition(position);

			// restart searching if the new position of the particle is outside
			// of the allowed region plus one linked cell in each direction
			// (again, one linked cell to avoid narrow regions)
			bool out = false;
			for (unsigned int d = 0; d < dim; d++) {
				if (position[d] >= allowed_high[d] + linkedCells->getCutoff()
						|| position[d] <= allowed_low[d]
								- linkedCells->getCutoff()) {
					out = true;
				}
			}
			
			// restart from random position if out of the allowed region _+ 
			// one linked cell
			if (out) {
				break;
			}

			// save old energy and compute new forces and energy
			*energyOld = *energy;
			molecule->clearFM();
			*energy = linkedCells->getForceAndEnergy(molecule, force);
			molecule->calcFM();

			wrapper.setForce(force);
			absForce = std::sqrt(force[0] * force[0] + 
					             force[1] * force[1] + 
					             force[2] * force[2]);

			// update step - one movement done
			timestep++;
			//writeMoleculeVtk(molecule, linkedCells, simulation, &timestep);
			writeToVectors(vec_energy, vec_angle, vec_lj, vec_center, *energy,
					0, molecule);

			// compute distance from target energy
			xiloc = fabs(*energy - U_0) / fabs(U_0);

			// if distance from target energy smaller than the tolerance
			if (fabs(xiloc) < xiMax) {

				// check if inside the allowed region (this time no one linked cell
			    // before and after)
				bool out = false;
				for (unsigned int d = 0; d < dim; d++) {
					if (position[d] >= allowed_high[d] || position[d]
							<= allowed_low[d]) {
						out = true;
					}
				}
				
				// restart if not in the allowed region
				if (out) {
					break;
				}
				doLogging(vec_energy, vec_angle, vec_lj, vec_center,
						name_energy, name_angle, name_lj, name_center);
				
				// within tolerance but not out of hte allowed region
				// meaning position is found 
				// output found position and final energy
				std::cout << "with force: " << molecule->F(0) << " "
						<< molecule->F(1) << " " << molecule->F(2) << std::endl;
				cout << "r: (after translation) " << molecule->r(0) << " "
						<< molecule->r(1) << " " << molecule->r(2)
						<< " energy: " << *energy << endl;
				return timestep;

			}

			// not within the tolerance, check if energy increased
			// in this iteration
			if (fabs(*energy - U_0) > fabs(*energyOld - U_0)) {
				// either restart
				if (restartIfIncreases) {
					
					break;
				} else {
					// or do a random rotation
					// that might lead to better energy
					q = Quaternion(rand() / (float) RAND_MAX,
							rand() / (float) RAND_MAX,
							rand() / (float) RAND_MAX,
							rand() / (float) RAND_MAX); //molecule->q();
					q.normalize();
					molecule->setq(q);
					molecule->upd_cache();
					*energyOld = *energy;

					// recalculate force and energy after the random rotation
					molecule->clearFM();
					*energy = linkedCells->getForceAndEnergy(molecule, force);

					wrapper.setForce(force);
					absForce = std::sqrt(
							force[0] * force[0] + force[1] * force[1]
									+ force[2] * force[2]);
					
					// increment performed steps (rotation performed)
					timestep++;
					//writeMoleculeVtk(molecule, linkedCells, simulation,
					//		&timestep);
					writeToVectors(vec_energy, vec_angle, vec_lj, vec_center,
							*energy, 0, molecule);

				}
			}

			// perform rotations until either max number of rotations reaced
			// or target energy found
			// or the computed angle was too large or too small
			int rotation = rotateMolecule(molecule, wrapper, linkedCells,
					rotationsMax, maxAngle, maxAllowedAngle, minAngle, U_0,
					U_overlap, &timestep, xiMax, energy, energyOld, force,
					&absForce, &q, 0, 0, vec_energy, vec_angle, vec_lj,
					vec_center, name_energy, name_angle, name_lj, name_center);

			// target reached after rotations
			if (rotation == 1) {
				// check if within allowed region
				bool out = false;
				for (unsigned int d = 0; d < dim; d++) {
					if (position[d] >= allowed_high[d] || position[d]
							<= allowed_low[d]) {
						out = true;
					}
				}
				
				// leave if not in the allowed region
				if (out) {
					break;
				}
				
				// target reached after rotations and within the allowed region
				// exit and write the final position and energy
				doLogging(vec_energy, vec_angle, vec_lj, vec_center,
						name_energy, name_angle, name_lj, name_center);
				cout << "r (after rotations): " << molecule->r(0) << " "
						<< molecule->r(1) << " " << molecule->r(2)
						<< " energy: " << *energy << std::endl;
				return timestep;
			}

		}

	}
	delete position;
	delete force;
	
	// algorithm failed
	// return -1 and write some output aboout the failure
	cout << "ran out of restarts " << endl;
	cout << "final energy: " << *energy << endl;
	cout << "total_steps: " << timestep << endl;
	cout << "restarts: " << restartMax << endl;
	return -1;
}
}
}
