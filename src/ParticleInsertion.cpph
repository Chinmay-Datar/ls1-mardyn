
/*
* Usher algorithm - inserting particles on
* the position where teh energy is euqal
* to the mean energy of the system
*/

namespace moleculardynamics {
namespace coupling {

template<class Molecule, class LinkedCells, unsigned int dim>
ParticleInsertion<Molecule, LinkedCells, dim>::ParticleInsertion() {
}

template<class Molecule, class LinkedCells, unsigned int dim>
void moleculardynamics::coupling::ParticleInsertion<Molecule, LinkedCells, dim>::write_vector(
		vector<double> vec, string file_name) const {
	/*
	FILE* file = fopen(file_name.c_str(), "w");
	for (unsigned int i = 0; i < vec.size(); i++) {
		fprintf(file, "%g \n", vec[i]);
	}
	fclose(file);
	*/
}

template<class Molecule, class LinkedCells, unsigned int dim>
void moleculardynamics::coupling::ParticleInsertion<Molecule, LinkedCells, dim>::write_vector_3d(
		std::vector<double*> vec, std::string file_name) const {
	/*
	FILE* file = fopen(file_name.c_str(), "w");
	for (unsigned int i = 0; i < vec.size(); i++) {
		fprintf(file, "%g %g %g \n", vec[i][0], vec[i][1], vec[i][2]);
	}
	fclose(file);
	*/
}

template<class Molecule, class LinkedCells, unsigned int dim>
void moleculardynamics::coupling::ParticleInsertion<Molecule, LinkedCells, dim>::doLogging(
		vector<double>* vec_energy, vector<double>* vec_angle,
		vector<double*>* vec_lj, vector<double*>* vec_center,
		string name_energy, string name_angle, string name_lj,
		string name_center) const {
	/*
	write_vector(*vec_energy, name_energy);
	write_vector(*vec_angle, name_angle);
	write_vector_3d(*vec_lj, name_lj);
	write_vector_3d(*vec_center, name_center);
	*/
}

template<class Molecule, class LinkedCells, unsigned int dim>
void moleculardynamics::coupling::ParticleInsertion<Molecule, LinkedCells, dim>::writeToVectors(
		vector<double>* vec_energy, vector<double>* vec_angle,
		vector<double*>* vec_lj, vector<double*>* vec_center, double energy,
		double angle, Molecule* molecule) const {
/*
	double* d1 = new double[3];
	d1[0] = molecule->ljcenter_d(0)[0];
	d1[1] = molecule->ljcenter_d(0)[1];
	d1[2] = molecule->ljcenter_d(0)[2];
	double* d2 = new double[3];
	d2[0] = molecule->ljcenter_d(1)[0];
	d2[1] = molecule->ljcenter_d(1)[1];
	d2[2] = molecule->ljcenter_d(1)[2];
	double* c = new double[3];
	c[0] = molecule->r(0);
	c[1] = molecule->r(1);
	c[2] = molecule->r(2);

	vec_lj->push_back(d1);
	vec_lj->push_back(d2);
	vec_center->push_back(c);
	vec_energy->push_back(energy);
	vec_angle->push_back(angle);
*/
}

template<class Molecule, class LinkedCells, unsigned int dim>
int moleculardynamics::coupling::ParticleInsertion<Molecule, LinkedCells, dim>::rotateMolecule(
		Molecule* molecule,
		moleculardynamics::coupling::interface::MardynMoleculeWrapper<Molecule,
				dim> wrapper, LinkedCells* linkedCells,
		int rotationsMax, double maxAngle, double maxAllowedAngle,
		double minAngle, double U_0, double U_overlap, int* timestep,
		double xiMax, double* energy, double* energyOld, double* force, double* absForce, Quaternion* q,
		bool stopIfOverlapping, bool log, vector<double>* vec_energy, vector<
				double>* vec_angle, vector<double*>* vec_lj,
		vector<double*>* vec_center, string name_energy, string name_angle,
		string name_lj, string name_center) const {

	double torque[3];
	double absTorque;
	double angle;

	for (int iRot = 0; iRot < rotationsMax && molecule->numSites() > 1; iRot++) {

		molecule->clearFM();
		*energy = linkedCells->getForceAndEnergy(molecule, force);
		molecule->calcFM();
		*absForce = std::sqrt(force[0] * force[0] + force[1] * force[1] + force[2] * force[2]);

		if (stopIfOverlapping && (*energy > U_overlap)) {
			//cout << "overlapping, stop rotation" << endl;
			return 0;
		}

		// get torque
		absTorque = 0;
		for (int i = 0; i < 3; i++)
			absTorque += molecule->M(i) * molecule->M(i);

		absTorque = std::sqrt(absTorque);

		for (int i = 0; i < 3; i++)
			torque[i] = (1 / absTorque) * molecule->M(i);

		angle = fabs(*energy - U_0) / absTorque;

		writeToVectors(vec_energy, vec_angle, vec_lj, vec_center, *energy,
				angle, molecule);

		// vtk file for visualization
		timestep++;
		//writeMoleculeVtk(molecule, linkedCells, simulation, timestep);

		double xiloc = fabs(*energy - U_0) / fabs(U_0);

		if (fabs(xiloc) < xiMax) {
			//cout << "final energy " << *energy << endl;
			return 1;
		}

		if (angle > maxAllowedAngle) {
			//cout << "angle too large, too far away" << endl;
			return 0;
		}
		if (angle > maxAngle) {
			//cout << "rotation angle to large, setting to maximal" << endl;
			angle = maxAngle;
		}

		if (angle < minAngle) {
			//cout << "angle too small, not rotating any more" << endl;
			return 0;
		}

		//perform rotation
		q->multiply_left(Quaternion(cos(angle / 2), torque[0] * sin(angle / 2),
				torque[1] * sin(angle / 2), torque[2] * sin(angle / 2)));

		molecule->setq(*q);
		molecule->upd_cache();

		*energyOld = *energy;

	}

	return 0;
}

/*
template<class Molecule, class LinkedCells, unsigned int dim>
void moleculardynamics::coupling::ParticleInsertion<Molecule, LinkedCells, dim>::writeMoleculeVtk(
		Molecule* molecule, LinkedCells* linkedCells, Simulation* simulation,
		int* timestep) const {
	Molecule* newMolecule = new Molecule(*molecule);
	newMolecule->setid(molecule->id() + 1);
	linkedCells->addParticle(*newMolecule);
	simulation->output(*timestep);
	Molecule * molec;
	for (molec = linkedCells->begin(); molec != linkedCells->end(); molec
			= linkedCells->next()) {
		if (molec->id() == newMolecule->id()) {

			linkedCells->deleteCurrent();
		}
	}
	linkedCells->update();
	delete newMolecule;
}
*/
template<class Molecule, class LinkedCells, unsigned int dim>
int moleculardynamics::coupling::ParticleInsertion<Molecule,
		LinkedCells, dim>::findParticlePosition(
		//moleculardynamics::coupling::MacroscopicCell<LinkedCells,dim>& thisCell,
		LinkedCells* linkedCells, 
		Molecule* molecule, double U_0, double* energy,
		double* energyOld, bool largeStepsizeOnOverlap,
		bool restartIfIncreases, int seed, int intIterMax, int restartMax,
		int rotationsMax, double maxAngle, double maxAllowedAngle,
		double minAngle, double xiMax, vector<double>* vec_energy, vector<
				double>* vec_angle, vector<double*>* vec_lj,
		vector<double*>* vec_center, string name_energy, string name_angle,
		string name_lj, string name_center, double* allowed_low, double* allowed_high) const {

	//int numMolecules = thisCell.getMoleculeCount();
	//cout<<"numMol "<<numMolecules<<endl;
	double* position = new double[3];

	// absolute value of force
	double absForce = 0.0;
	// step size
	double stepSize;

	// fluid parameters
	const double epsilon_times_4 = 4.0 * molecule->getEps();
	const double sigma = molecule->getSigma();

	const double rSigma = 0.9 * sigma;
	//FIXME: add a coefficient like in peter's implementation
	// const double U_0 = _config.getMeanPotentialEnergyFactor() * thisCell.getPotentialEnergy();

	//vector<Molecule*> molecules = thisCell.getParticlePointers();
	molecule->clearFM();

	double* force = new double[3];

	// energy implying a certain overlap with another particle (including rescaling to LB scaling)
	//FIXME: add a coefficient like in peter's implementation
	// const double U_overlap = _config.getUOverlapCoeff()*moleculardynamics::coupling::services::CouplingMDSolverService<Molecule,LinkedCells,dim>::getInstance().getMoleculeEpsilon();
	const double U_overlap = 10000 * molecule->getEps();

	// termination criterion (if relative energy |U-U0|/|U0| is smaller than xiMax, search can be stopped)
	// const double xiMax = _config.getMeanPotentialEnergyFactor()/2.0;


	// maximum step size allowed
	const double stepRef = 1.12 * sigma; //0.1
			//* pow((1.0 / ((double) numMolecules)), 3.0 / 2.0) * sigma;

	int timestep = 0;

	// upper right... corner of macroscopic cell
	double* upperRightCorner = linkedCells->boundingBoxMax();

	// wrapper for the molecule
	moleculardynamics::coupling::interface::MardynMoleculeWrapper<Molecule, dim>
			wrapper(molecule);

	// initialize random numbers 
	srand(seed);
	Quaternion q;
	// try at max. restartMax times to insert this particle...
	for (int i = 0; i < restartMax; i++) {

		// TODO TEST: Always insert very close to interface
		//tarch::la::Vector<dim, double> nearInterface(macroscopicCellPosition);
		//tarch::la::Vector<dim, double> nearInterfaceCellSize(
		//	macroscopicCellSize);

		// FIXME: check if RandGen of mardyn should be used
		// generate random position and rotation
		/*
		position[0] = linkedCells->boundingBoxMin()[0]
							+ linkedCells->boundingBoxMax()[0] * rand() / (float) RAND_MAX;
		position[1] = linkedCells->boundingBoxMin()[1]
									+ linkedCells->boundingBoxMax()[1] * rand() / (float) RAND_MAX;
		
		for (unsigned int d = 2; d < dim; d++) {
			position[d] = linkedCells->boundingBoxMin()[d]
				+ linkedCells->cellLength()[d] * rand() / (float) RAND_MAX;
		}
		*/
		int diff[3];
		for (int d = 0; d < 3; d++) diff[d] = allowed_high[d] - allowed_low[d];

		for (unsigned int d = 0; d < dim; d++) {
				position[d] = allowed_low[d]
					+ diff[d] * (rand() / (float) RAND_MAX);
		}
		
		q = Quaternion(rand(), rand(), rand(), rand());
		q.normalize();

		wrapper.setPosition(position);
		molecule->setq(q);
		molecule->upd_cache();

		for (int d = 0; d < 3; d++) force[d] = 0;
		molecule->clearFM();
		*energy = linkedCells->getForceAndEnergy(molecule, force);

		wrapper.setForce(force);
		absForce = std::sqrt(force[0] * force[0] + force[1] * force[1] + force[2] * force[2]);

		writeToVectors(vec_energy, vec_angle, vec_lj, vec_center, *energy, 0,
				molecule);
		// for the vtk file
		timestep++;
		//writeMoleculeVtk(molecule, linkedCells, simulation, &timestep);

		if (*energy - U_0 == 0.0) {
			cout << "exactly zero difference. done. " << endl;
			cout << "total_steps: " << timestep << endl;
			cout << "restarts: " << i << endl;
			doLogging(vec_energy, vec_angle, vec_lj, vec_center, name_energy,
					name_angle, name_lj, name_center);
			return timestep;
		}

		// determine signum
		const int signAl = static_cast<int> ((*energy - U_0) / fabs(*energy
				- U_0));

		if ((signAl != 1) && (signAl != -1)) {
			std::cout
					<< "ERROR moleculardynamics::coupling::ParticleInsertion::findParticlePosition(): wrong sign in USHER"
					<< std::endl;
			doLogging(vec_energy, vec_angle, vec_lj, vec_center, name_energy,
					name_angle, name_lj, name_center);
			exit( EXIT_FAILURE);
		}

		// do steps towards expected energy level
		double xiloc = xiMax + 1.0;

		for (int loci = 0; loci < intIterMax; loci++) {
			// if there is no force on the particle, 
			// either out of cuttof (also energy == 0), or in the
			// center of mass of the system
			if (absForce == 0) {
				break;
			}

			// control step size
			if (*energy > U_overlap) {
				if (largeStepsizeOnOverlap) {
					stepSize = 1.12 * sigma - sigma * pow(epsilon_times_4 / *energy,
							(1.0 / 12.0));
					//std::cout<<"large stepsize: "<<stepSize<<std::endl;
				} else {
					stepSize = fabs(*energy - U_0) / absForce;
				}
			} else {
				stepSize = fabs(*energy - U_0) / absForce;
				if (stepSize > stepRef) {
					stepSize = stepRef;
				}

			}

			if (stepSize <= 0.0) {
				
				doLogging(vec_energy, vec_angle, vec_lj, vec_center,
						name_energy, name_angle, name_lj, name_center);
				exit( EXIT_FAILURE);
			}

			// update particle position
			for (int d = 0; d < 3; d++)
			position[d] = position[d] + (stepSize * signAl / absForce) * force[d];
			wrapper.setPosition(position);

			// restart searching if the new position of the particle is outside the macroscopic cell
			bool out = false;
			for (unsigned int d = 0; d < dim; d++) {
				if (position[d] >= allowed_high[d] || position[d]
						<= allowed_low[d]) {
					out = true;
				}
			}
			if (out) {
				//cout << "out of the bounding box, restarting" << endl;
				break;
			}

			// save old energy and compute new forces and energy
			*energyOld = *energy;
			molecule->clearFM();
			*energy = linkedCells->getForceAndEnergy(molecule, force);

			wrapper.setForce(force);
			absForce = std::sqrt(force[0] * force[0] + force[1] * force[1] + force[2] * force[2]);

			// just for visualizing how the molecule is searching for a position
			timestep++;
			//writeMoleculeVtk(molecule, linkedCells, simulation, &timestep);
			writeToVectors(vec_energy, vec_angle, vec_lj, vec_center, *energy,
					0, molecule);

			xiloc = fabs(*energy - U_0) / fabs(U_0);

			if (fabs(xiloc) < xiMax) {
			
				doLogging(vec_energy, vec_angle, vec_lj, vec_center,
						name_energy, name_angle, name_lj, name_center);
				cout<<"r: "<<molecule->r(0)<<" "<<molecule->r(1)<<" "<<molecule->r(2)<<" energy: "<<*energy<<endl;
				return timestep;

			}

			if (fabs(*energy - U_0) > fabs(*energyOld - U_0)) {
				if (restartIfIncreases) {
					//cout << "restart because energy increases" << endl;
					break;
				} else {
					q = Quaternion(rand(), rand(), rand(), rand()); //molecule->q();
					q.normalize();
					molecule->setq(q);
					molecule->upd_cache();
					*energyOld = *energy;
		
					molecule->clearFM();
					*energy = linkedCells->getForceAndEnergy(molecule, force);

					wrapper.setForce(force);
					absForce = std::sqrt(force[0] * force[0] + force[1] * force[1] + force[2] * force[2]);
					timestep++;
					//writeMoleculeVtk(molecule, linkedCells, simulation,
					//		&timestep);
					writeToVectors(vec_energy, vec_angle, vec_lj, vec_center,
							*energy, 0, molecule);

				}
			}

			// if the molecules have more than one interaction site, perform rotations

			int rotation = rotateMolecule(molecule, wrapper, linkedCells,
					rotationsMax, maxAngle, maxAllowedAngle,
					minAngle, U_0, U_overlap, &timestep, xiMax, energy,
					energyOld, force, &absForce, &q, 0, 0, vec_energy,
					vec_angle, vec_lj, vec_center, name_energy, name_angle,
					name_lj, name_center);
			
			if (rotation == 1) {
				doLogging(vec_energy, vec_angle, vec_lj, vec_center,
						name_energy, name_angle, name_lj, name_center);
				cout<<"r: "<<molecule->r(0)<<" "<<molecule->r(1)<<" "<<molecule->r(2)<<" energy: "<<*energy<<std::endl;
				return timestep;
			}
			

		}
		
	}
	delete position;
	delete force;
	//return moleculardynamics::coupling::ParticleInsertion<Molecule,LinkedCells,dim>::NoAction;
	cout << "ran out of restarts " << endl;
	cout << "final energy: " << *energy << endl;
	cout << "total_steps: " << timestep << endl;
	cout << "restarts: " << restartMax << endl;
	return -1;
}
}
}
